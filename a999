--[[
	Hydra UI Library
	A simple, modern UI library inspired by the structure of OrionLib.
	Version 1.4 - Fixed Dropdown Selection Click-Through, Fixed Slider Cursor Visibility Bug.
	Features:
		- Draggable Window
		- Tabs
		- Sliders
		- Toggles (Checkboxes)
		- Dropdowns
--]]

local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local HydraLib = {}
HydraLib.__index = HydraLib
HydraLib._windows = {}
local BASE_ZINDEX_COUNTER = 1 -- Start counter for base Z-indices for different windows

--==============================================================================--
--                           INTERNAL HELPER FUNCTIONS                          --
--==============================================================================--
-- These create the actual GUI elements and are not directly called by the user.

local function _createSlider(parent, config)
	local minValue = config.Min or 0
	local maxValue = config.Max or 100
	local initialValue = math.clamp(config.Default or minValue, minValue, maxValue)
	local label = config.Name or "Slider"
	local valueName = config.ValueName or ""
	local increment = config.Increment or 1
	if increment <= 0 then increment = 1 end -- Prevent zero/negative increment
	local callback = config.Callback or function() end

	local container = Instance.new("Frame")
	container.Name = label:gsub("%s+", "") .. "SliderContainer"
	container.Size = UDim2.new(1, 0, 0, 45)
	container.BackgroundTransparency = 1
	container.Parent = parent
	container.LayoutOrder = config._LayoutOrder or 0
	container.Active = false -- Container doesn't need input

	local SliderLabel = Instance.new("TextLabel", container)
	SliderLabel.Size = UDim2.new(1, 0, 0, 15)
	SliderLabel.Position = UDim2.new(0, 0, 0, 0)
	SliderLabel.BackgroundTransparency = 1
	SliderLabel.Font = Enum.Font.Gotham
	SliderLabel.TextSize = 14
	SliderLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	SliderLabel.TextXAlignment = Enum.TextXAlignment.Left
	SliderLabel.ZIndex = container.ZIndex + 1

	local SliderFrame = Instance.new("Frame", container)
	SliderFrame.Name = "SliderTrack"
	SliderFrame.Size = UDim2.new(1, 0, 0, 10)
	SliderFrame.Position = UDim2.new(0, 0, 0, 20)
	SliderFrame.BackgroundColor3 = config.TrackColor or Color3.fromRGB(50, 50, 50)
	SliderFrame.BorderSizePixel = 0
	SliderFrame.Active = true -- MUST be active to receive input
	SliderFrame.ZIndex = container.ZIndex + 1
	local SliderCorner = Instance.new("UICorner", SliderFrame)
	SliderCorner.CornerRadius = UDim.new(0, 5)

	local Fill = Instance.new("Frame", SliderFrame)
	Fill.Name = "SliderFill"
	Fill.BackgroundColor3 = config.Color or Color3.fromRGB(0, 120, 255)
	Fill.BorderSizePixel = 0
	Fill.ZIndex = SliderFrame.ZIndex + 1 -- Above track
	local FillCorner = Instance.new("UICorner", Fill)
	FillCorner.CornerRadius = UDim.new(0, 5)

	local currentSliderValue = initialValue
	local isDraggingSlider = false
	local dragMoveConnection = nil
	local globalReleaseConnection = nil -- Changed from dragReleaseConnection for clarity

	-- Function to calculate ratio based on input position relative to the SliderFrame
	local function calculateRatioFromInput(inputPosition)
		-- Ensure frame exists and has valid size before calculating
		if not SliderFrame or not SliderFrame.Parent then return 0 end
		local frameAbsPos = SliderFrame.AbsolutePosition
		local frameAbsSize = SliderFrame.AbsoluteSize
		if not frameAbsSize or frameAbsSize.X <= 0 then
			local range = maxValue - minValue
			return range > 0 and math.clamp((currentSliderValue - minValue) / range, 0, 1) or 0 -- Return current ratio if width is zero/invalid
		end
		local relativeX = inputPosition.X - frameAbsPos.X
		local totalWidth = frameAbsSize.X
		return math.clamp(relativeX / totalWidth, 0, 1)
	end

	-- Function to update slider visuals and optionally trigger callback
	local function updateSliderDisplay(ratio, triggerCallback)
		ratio = math.clamp(ratio, 0, 1)
		local range = maxValue - minValue
		if range <= 0 then range = 1 end -- Avoid division by zero or negative range
		local rawValue = minValue + ratio * range
		local steppedValue = math.floor(rawValue / increment + 0.5) * increment
		local finalValue = math.clamp(steppedValue, minValue, maxValue)
		local displayRatio = range > 0 and math.clamp((finalValue - minValue) / range, 0, 1) or 0

		-- Update visuals instantly during drag for responsiveness
		if Fill and Fill.Parent then -- Ensure Fill still exists
			Fill.Size = UDim2.new(displayRatio, 0, 1, 0)
		end
		if SliderLabel and SliderLabel.Parent then -- Ensure Label still exists
            -- Display the *actual* current value immediately
			SliderLabel.Text = label .. ": " .. string.format("%.f", finalValue) .. (valueName ~= "" and " " .. valueName or "")
		end

		-- Trigger callback only if the value actually changed
		if finalValue ~= currentSliderValue then
			currentSliderValue = finalValue
			if triggerCallback then
				task.spawn(callback, currentSliderValue) -- Use task.spawn to prevent callback yielding UI thread
			end
		end
	end

	-- Function to clean up drag connections
	local function cleanupDragConnections()
		if dragMoveConnection then dragMoveConnection:Disconnect(); dragMoveConnection = nil end
		if globalReleaseConnection then globalReleaseConnection:Disconnect(); globalReleaseConnection = nil end
	end

	-- Handle InputBegan on the slider track
	SliderFrame.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not isDraggingSlider then
			isDraggingSlider = true
			UserInputService.MouseIconEnabled = false -- Hide mouse cursor on drag start

			local currentRatio = calculateRatioFromInput(input.Position)
			updateSliderDisplay(currentRatio, true) -- Update and trigger callback on initial press

			cleanupDragConnections() -- Clean up any old connections just in case

			-- Connect to global InputChanged for smooth dragging
			dragMoveConnection = UserInputService.InputChanged:Connect(function(moveInput)
				-- Ensure we are still dragging and the input type is relevant
				if isDraggingSlider and (moveInput.UserInputType == Enum.UserInputType.MouseMovement or moveInput.UserInputType == Enum.UserInputType.Touch) then
					-- Check if slider still exists before processing move
					if not SliderFrame or not SliderFrame.Parent then
						isDraggingSlider = false
						UserInputService.MouseIconEnabled = true -- Ensure cursor is re-enabled
						cleanupDragConnections()
						return
					end
					local ratio = calculateRatioFromInput(moveInput.Position)
					updateSliderDisplay(ratio, true) -- Update display AND trigger callback as value changes
				end
			end)

			-- Use a global InputEnded for release, as mouse might leave the frame
			globalReleaseConnection = UserInputService.InputEnded:Connect(function(endInput)
				-- Check if this input end corresponds to the button release we care about
				if (endInput.UserInputType == Enum.UserInputType.MouseButton1 or endInput.UserInputType == Enum.UserInputType.Touch) then
					local wasDragging = isDraggingSlider -- Store state before potentially changing it
					isDraggingSlider = false -- Assume drag ends on any release

					-- *** Robust Cursor Reset ***
					-- Always try to re-enable the mouse icon on release, regardless of the isDraggingSlider flag's state *at this exact moment*,
					-- but only if it was actually hidden by this slider instance (implied by wasDragging being true).
					-- Or simply: always re-enable if a drag *was* in progress.
					if wasDragging then
						UserInputService.MouseIconEnabled = true
					end

					-- Clean up connections associated with this drag instance
					cleanupDragConnections()
				end
			end)
		end
	end)

	-- Initialize slider display
	local initialRatio = (maxValue - minValue) > 0 and math.clamp((initialValue - minValue) / (maxValue - minValue), 0, 1) or 0
	updateSliderDisplay(initialRatio, false) -- Update display only on init, don't trigger callback

	-- Setter function for programmatic control
	local function setter(newValue)
		if type(newValue) == "number" then
			local range = maxValue - minValue
			if range <= 0 then return end -- Avoid division by zero or negative range
			local clampedValue = math.clamp(newValue, minValue, maxValue)
			local newRatio = math.clamp((clampedValue - minValue) / range, 0, 1)
			-- Ensure slider parts still exist before setting
			if container and container.Parent then
				updateSliderDisplay(newRatio, false) -- Update display only, no callback from setter
			end
		end
	end

	-- Cleanup connections if the container is destroyed
	container.Destroying:Connect(function()
		-- If dragging when destroyed, ensure mouse icon is reset
		if isDraggingSlider then
			UserInputService.MouseIconEnabled = true
		end
		cleanupDragConnections()
	end)


	return container, setter
end


local function _createToggle(parent, config)
	local labelText = config.Name or "Toggle"
	local initialValue = config.Default or false
	local callback = config.Callback or function() end
	local toggled = initialValue

	local toggleHeight = 25
	local checkboxSize = 18
	local spacing = 8

	local Container = Instance.new("Frame")
	Container.Name = labelText:gsub("%s+", "") .. "ToggleContainer"
	Container.Size = UDim2.new(1, 0, 0, toggleHeight)
	Container.BackgroundTransparency = 1
	Container.Parent = parent
	Container.LayoutOrder = config._LayoutOrder or 0
	Container.Active = false

	local Label = Instance.new("TextLabel")
	Label.Name = "Label"
	Label.Size = UDim2.new(1, -(checkboxSize + spacing), 1, 0)
	Label.Position = UDim2.new(0, 0, 0, 0)
	Label.BackgroundTransparency = 1
	Label.Font = Enum.Font.Gotham
	Label.Text = labelText
	Label.TextColor3 = Color3.fromRGB(220, 220, 220)
	Label.TextSize = 16
	Label.TextXAlignment = Enum.TextXAlignment.Left
	Label.TextYAlignment = Enum.TextYAlignment.Center
	Label.Parent = Container
	Label.ZIndex = Container.ZIndex + 1

	local CheckboxFrame = Instance.new("Frame")
	CheckboxFrame.Name = "CheckboxFrame"
	CheckboxFrame.Size = UDim2.new(0, checkboxSize, 0, checkboxSize)
	CheckboxFrame.Position = UDim2.new(1, -checkboxSize, 0.5, -checkboxSize / 2)
	CheckboxFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	CheckboxFrame.BorderSizePixel = 1
	CheckboxFrame.BorderColor3 = Color3.fromRGB(90, 90, 90)
	CheckboxFrame.Parent = Container
	CheckboxFrame.ZIndex = Container.ZIndex + 1
	local CheckboxCorner = Instance.new("UICorner", CheckboxFrame)
	CheckboxCorner.CornerRadius = UDim.new(0, 4)

	local Checkmark = Instance.new("Frame", CheckboxFrame)
	Checkmark.Name = "Checkmark"
	Checkmark.Size = UDim2.new(0.7, 0, 0.7, 0)
	Checkmark.Position = UDim2.new(0.5, 0, 0.5, 0)
	Checkmark.AnchorPoint = Vector2.new(0.5, 0.5)
	Checkmark.BackgroundColor3 = config.Color or Color3.fromRGB(0, 180, 90)
	Checkmark.BorderSizePixel = 0
	Checkmark.BackgroundTransparency = 1 -- Start transparent
	Checkmark.ZIndex = CheckboxFrame.ZIndex + 1
	local CheckmarkCorner = Instance.new("UICorner", Checkmark)
	CheckmarkCorner.CornerRadius = UDim.new(0, 3)

	local ClickButton = Instance.new("TextButton", Container)
	ClickButton.Name = "ClickArea"
	ClickButton.Size = UDim2.new(1, 0, 1, 0)
	ClickButton.BackgroundTransparency = 1
	ClickButton.Text = ""
	ClickButton.ZIndex = Container.ZIndex + 2 -- Above other visuals

	local function updateVisuals(state)
		-- Use Tween for smooth transition if instances exist
		if Checkmark and Checkmark.Parent and CheckboxFrame and CheckboxFrame.Parent then
			local targetTransparency = state and 0 or 1
			local targetBgColor = state and Color3.fromRGB(70, 70, 70) or Color3.fromRGB(60, 60, 60)
			TweenService:Create(Checkmark, TweenInfo.new(0.1), {BackgroundTransparency = targetTransparency}):Play()
			TweenService:Create(CheckboxFrame, TweenInfo.new(0.1), {BackgroundColor3 = targetBgColor}):Play()
		end
	end

	ClickButton.MouseButton1Click:Connect(function()
		toggled = not toggled
		updateVisuals(toggled)
		task.spawn(callback, toggled)
	end)

	-- Set initial state without tween
	if Checkmark and Checkmark.Parent and CheckboxFrame and CheckboxFrame.Parent then
		Checkmark.BackgroundTransparency = toggled and 0 or 1
		CheckboxFrame.BackgroundColor3 = toggled and Color3.fromRGB(70, 70, 70) or Color3.fromRGB(60, 60, 60)
	end

	local function setter(newState)
		if type(newState) == "boolean" and newState ~= toggled then
			toggled = newState
			updateVisuals(toggled) -- Update visuals when set programmatically
		end
	end

	return Container, setter
end


local function _createDropdown(parent, config, screenGuiRef, baseZIndex)
	local labelText = config.Name or "Dropdown"
	local options = config.Options or {"Option 1"}
	local defaultOption = config.Default
	local callback = config.Callback or function() end

	local selectedIndex = 1
	if defaultOption then
		for i, v in ipairs(options) do
			if v == defaultOption then
				selectedIndex = i
				break
			end
		end
	end
	local selectedOptionText = #options > 0 and options[selectedIndex] or "Select..."
	local isOpen = false

	local dropdownBaseHeight = 30
	local labelHeight = 18
	local totalControlHeight = dropdownBaseHeight + labelHeight
	local optionsVisibleMaxHeight = 150 -- Max height before scroll appears
	local optionHeight = 25

	local Container = Instance.new("Frame")
	Container.Name = labelText:gsub("%s+", "") .. "DropdownContainer"
	Container.Size = UDim2.new(1, 0, 0, totalControlHeight)
	Container.BackgroundTransparency = 1
	Container.ClipsDescendants = false -- CRITICAL: Must be false so OptionsFrame can draw outside
	Container.Parent = parent
	Container.LayoutOrder = config._LayoutOrder or 0
	Container.ZIndex = baseZIndex -- Use provided base ZIndex for closed state

	local Label = Instance.new("TextLabel")
	Label.Name = "Label"
	Label.Size = UDim2.new(1, 0, 0, labelHeight)
	Label.Position = UDim2.new(0, 0, 0, 0)
	Label.BackgroundTransparency = 1
	Label.Font = Enum.Font.Gotham
	Label.Text = labelText
	Label.TextColor3 = Color3.fromRGB(200, 200, 200)
	Label.TextSize = 14
	Label.TextXAlignment = Enum.TextXAlignment.Left
	Label.TextYAlignment = Enum.TextYAlignment.Bottom
	Label.Parent = Container
	Label.ZIndex = Container.ZIndex + 1

	local DisplayButton = Instance.new("TextButton")
	DisplayButton.Name = "DisplayButton"
	DisplayButton.Size = UDim2.new(1, 0, 0, dropdownBaseHeight)
	DisplayButton.Position = UDim2.new(0, 0, 0, labelHeight)
	DisplayButton.BackgroundColor3 = config.Color or Color3.fromRGB(55, 55, 55)
	DisplayButton.Font = Enum.Font.GothamSemibold
	DisplayButton.Text = selectedOptionText .. " ▼"
	DisplayButton.TextColor3 = Color3.fromRGB(210, 210, 210)
	DisplayButton.TextSize = 14
	DisplayButton.TextXAlignment = Enum.TextXAlignment.Left
	DisplayButton.AutoButtonColor = false
	DisplayButton.Parent = Container
	DisplayButton.ZIndex = Container.ZIndex + 1 -- Slightly above container background
	local DisplayCorner = Instance.new("UICorner", DisplayButton)
	DisplayCorner.CornerRadius = UDim.new(0, 6)
	local DisplayPadding = Instance.new("UIPadding", DisplayButton)
	DisplayPadding.PaddingLeft = UDim.new(0, 8)
	DisplayPadding.PaddingRight = UDim.new(0, 8)

	local OptionsFrame = Instance.new("ScrollingFrame")
	OptionsFrame.Name = "OptionsFrame"
	OptionsFrame.Size = UDim2.new(1, 0, 0, 0) -- Initial height 0, calculated later
	OptionsFrame.Position = UDim2.new(0, 0, 1, 2) -- Position below the button
	OptionsFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	OptionsFrame.BorderSizePixel = 1
	OptionsFrame.BorderColor3 = Color3.fromRGB(70, 70, 70)
	OptionsFrame.Visible = false -- Start hidden
	OptionsFrame.ClipsDescendants = true -- Clip the *content* (options) if scrolling
	OptionsFrame.Parent = Container -- Parent is the container
	OptionsFrame.ZIndex = baseZIndex + 100 -- High Z-index RELATIVE TO BASE for when it's visible
	OptionsFrame.ScrollBarThickness = 5
	OptionsFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
	OptionsFrame.ScrollingDirection = Enum.ScrollingDirection.Y
	OptionsFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y -- Let layout handle canvas height
	OptionsFrame.CanvasPosition = Vector2.new()
	local OptionsCorner = Instance.new("UICorner", OptionsFrame)
	OptionsCorner.CornerRadius = UDim.new(0, 6)
	local OptionsLayout = Instance.new("UIListLayout", OptionsFrame)
	OptionsLayout.SortOrder = Enum.SortOrder.LayoutOrder
	OptionsLayout.Padding = UDim.new(0, 2)
	local OptionsPadding = Instance.new("UIPadding", OptionsFrame)
	OptionsPadding.PaddingTop = UDim.new(0, 4)
	OptionsPadding.PaddingBottom = UDim.new(0, 4)
	OptionsPadding.PaddingLeft = UDim.new(0, 4)
	OptionsPadding.PaddingRight = UDim.new(0, 4)

	local currentDismissButton = nil
	local currentDismissConn = nil

	-- Function to close the dropdown
	local function closeDropdown(triggerCallback, newIndex, newText)
		if not isOpen then return end
		isOpen = false

		local oldIndex = selectedIndex
		if newIndex then selectedIndex = newIndex end
		if newText then selectedOptionText = newText end

		-- Check if DisplayButton still exists before modifying
		if DisplayButton and DisplayButton.Parent then
			DisplayButton.Text = selectedOptionText .. " ▼" -- Update text
		end

		-- Check if OptionsFrame still exists before modifying
		if OptionsFrame and OptionsFrame.Parent then
			OptionsFrame.Visible = false -- Hide options
		end

		-- Check if Container still exists before modifying ZIndex
		if Container and Container.Parent then
			Container.ZIndex = baseZIndex -- *** Reset Container ZIndex to base ***
		end

		-- Clean up dismiss layer
		if currentDismissButton and currentDismissButton.Parent then
			currentDismissButton:Destroy()
			currentDismissButton = nil
		end
		if currentDismissConn then
			currentDismissConn:Disconnect()
			currentDismissConn = nil
		end

		-- Trigger callback if selection changed
		if triggerCallback and selectedIndex ~= oldIndex then
			task.spawn(callback, selectedOptionText)
		end
	end

	-- Function called when an option button is clicked
	local function selectOption(index, optionText)
		-- Ensure Container/OptionsFrame still exist before trying to close
		if Container and Container.Parent and OptionsFrame and OptionsFrame.Parent then
			closeDropdown(true, index, optionText) -- Close, trigger callback, update index/text
		end
	end

	-- Function to build/rebuild the option buttons inside the scrolling frame
	local function buildOptions()
        -- Ensure OptionsFrame exists before manipulating children
		if not OptionsFrame or not OptionsFrame.Parent then return end

		-- Clear existing option buttons only
		for _, child in ipairs(OptionsFrame:GetChildren()) do
			if child:IsA("TextButton") then
				child:Destroy()
			end
		end

		if #options == 0 then
			OptionsFrame.Size = UDim2.new(1, 0, 0, 0) -- Collapse if no options
			OptionsFrame.CanvasSize = UDim2.new(0,0,0,0) -- Reset canvas size
			return
		end

		-- Create new option buttons
		for index, optionText in ipairs(options) do
			local OptionButton = Instance.new("TextButton")
			OptionButton.Name = "Option_" .. index
			OptionButton.Size = UDim2.new(1, 0, 0, optionHeight) -- Size based on fixed height
			OptionButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
			OptionButton.BackgroundTransparency = 0.5
			OptionButton.BorderSizePixel = 0
			OptionButton.Font = Enum.Font.Gotham
			OptionButton.Text = optionText
			OptionButton.TextColor3 = Color3.fromRGB(200, 200, 200)
			OptionButton.TextSize = 14
			OptionButton.LayoutOrder = index
			OptionButton.AutoButtonColor = false
			OptionButton.Parent = OptionsFrame
			OptionButton.ZIndex = OptionsFrame.ZIndex + 1 -- Above options frame background

			OptionButton.MouseEnter:Connect(function()
                if OptionButton and OptionButton.Parent then -- Check exists
				    TweenService:Create(OptionButton, TweenInfo.new(0.1), {BackgroundTransparency = 0.2}):Play()
                end
            end)
			OptionButton.MouseLeave:Connect(function()
                if OptionButton and OptionButton.Parent then -- Check exists
				    TweenService:Create(OptionButton, TweenInfo.new(0.1), {BackgroundTransparency = 0.5}):Play()
                end
            end)

			OptionButton.MouseButton1Click:Connect(function()
                -- Call selectOption which handles closing and callback
				selectOption(index, optionText)
			end)
		end

		-- Defer size calculation slightly to ensure layout calculation completes
		task.defer(function()
			if not OptionsFrame or not OptionsFrame.Parent or not OptionsLayout then return end -- Check if destroyed
			local totalContentHeight = OptionsLayout.AbsoluteContentSize.Y
			local optionsFrameVisibleHeight = math.min(totalContentHeight, optionsVisibleMaxHeight)
			OptionsFrame.Size = UDim2.new(1, 0, 0, optionsFrameVisibleHeight)
		end)
	end

	-- Handle click on the main display button (to open/close)
	DisplayButton.MouseButton1Click:Connect(function()
        -- Ensure container exists before proceeding
		if not Container or not Container.Parent then return end

		if isOpen then
			closeDropdown(false) -- Close without triggering callback
		else
			-- Open the dropdown
			isOpen = true

            -- Ensure parts exist before modifying
            if OptionsFrame and OptionsFrame.Parent then OptionsFrame.Visible = true end
            if DisplayButton and DisplayButton.Parent then DisplayButton.Text = selectedOptionText .. " ▲" end -- Change arrow direction

			-- *** CRITICAL: Bring the *entire container* to the front ***
			Container.ZIndex = baseZIndex + 150 -- Significantly higher than base

			-- Optional: Rebuild options in case they changed dynamically while closed
			-- buildOptions()

			-- Create dismiss layer (full screen, transparent button)
			if currentDismissButton and currentDismissButton.Parent then currentDismissButton:Destroy() end
			if currentDismissConn then currentDismissConn:Disconnect() end

			currentDismissButton = Instance.new("TextButton")
			currentDismissButton.Name = "HydraDismissDropdown"
			currentDismissButton.Size = UDim2.new(1, 0, 1, 0)
			currentDismissButton.Position = UDim2.new(0,0,0,0)
			currentDismissButton.BackgroundTransparency = 1 -- Fully transparent
			currentDismissButton.Text = ""
			-- ZIndex *below* the opened container, but *above* most other UI
			currentDismissButton.ZIndex = Container.ZIndex - 1
            currentDismissButton.Parent = screenGuiRef -- Parent to ScreenGui

			-- Connect click on dismiss layer to close the dropdown
			currentDismissConn = currentDismissButton.MouseButton1Click:Connect(function()
                -- **FIX:** Check if mouse is over the options frame before dismissing
                if not OptionsFrame or not OptionsFrame.Parent then -- If options frame gone, just close
                    closeDropdown(false)
                    return
                end

                local mouseLocation = UserInputService:GetMouseLocation()
                local framePos = OptionsFrame.AbsolutePosition
                local frameSize = OptionsFrame.AbsoluteSize

                -- Create a small tolerance (e.g., 2 pixels) if needed
                local tolerance = 0
                if mouseLocation.X >= framePos.X - tolerance and mouseLocation.X <= framePos.X + frameSize.X + tolerance and
                   mouseLocation.Y >= framePos.Y - tolerance and mouseLocation.Y <= framePos.Y + frameSize.Y + tolerance then
                    -- Mouse is over the options frame (or very close), let the option button handle the click
                    -- Do nothing here, the click should fall through to the OptionButton below.
                    return
                end

                -- Mouse is outside the options frame, close the dropdown
				closeDropdown(false)
			end)
		end
	end)

	-- Build initial options
	buildOptions()

	-- Setter function
	local function setter(optionValue)
        -- Ensure button exists before setting
        if not DisplayButton or not DisplayButton.Parent then return false end

		local found = false
		local previousIndex = selectedIndex
		for i, v in ipairs(options) do
			if v == optionValue then
				selectedIndex = i
				selectedOptionText = v
				DisplayButton.Text = selectedOptionText .. (isOpen and " ▲" or " ▼") -- Update text
				found = true
				-- Don't trigger callback on programmatic set
				break
			end
		end
		return found
	end

	-- Refresher function to update options list
	local function refresher(newOptions, clearCurrentSelection)
        -- Ensure required elements exist
		if not OptionsFrame or not OptionsFrame.Parent or not DisplayButton or not DisplayButton.Parent then return end

		options = newOptions or {}
		local currentValid = false

		-- Check if current selection is still valid in the new list
		if not clearCurrentSelection and selectedIndex >= 1 and selectedIndex <= #options then
			-- More robust check: compare actual text value if possible
            if options[selectedIndex] == selectedOptionText then
                 currentValid = true
            end
		end

		if clearCurrentSelection or not currentValid then
			selectedIndex = 1 -- Reset if cleared or old selection invalid/missing
            if #options == 0 then selectedIndex = 0 end -- Handle edge case of empty list
		end

		-- Update selected text based on new index or default
        if selectedIndex > 0 and selectedIndex <= #options then
            selectedOptionText = options[selectedIndex]
        elseif #options > 0 then
             -- Fallback to first option if index became invalid but list not empty
             selectedIndex = 1
             selectedOptionText = options[selectedIndex]
        else
            selectedOptionText = "Select..." -- List is empty
        end

		DisplayButton.Text = selectedOptionText .. (isOpen and " ▲" or " ▼") -- Update display text
		buildOptions() -- Rebuild with new options

		-- If it was open, re-adjust size after build
		if isOpen then
			task.defer(function()
				if not OptionsFrame or not OptionsFrame.Parent or not OptionsLayout then return end
				local totalContentHeight = OptionsLayout.AbsoluteContentSize.Y
				local optionsFrameVisibleHeight = math.min(totalContentHeight, optionsVisibleMaxHeight)
				OptionsFrame.Size = UDim2.new(1, 0, 0, optionsFrameVisibleHeight)
			end)
		end
	end

    -- Cleanup on destroy
    Container.Destroying:Connect(function()
         -- Ensure dismiss layer is removed if container is destroyed while open
         if currentDismissButton and currentDismissButton.Parent then
             currentDismissButton:Destroy()
         end
         if currentDismissConn then
             currentDismissConn:Disconnect()
         end
         currentDismissButton = nil
         currentDismissConn = nil
    end)

	return Container, setter, refresher
end


--==============================================================================--
--                             LIBRARY MAIN METHODS                             --
--==============================================================================--

function HydraLib:MakeWindow(config)
	config = config or {}
	local window = {}
	setmetatable(window, HydraLib) -- Allow calling HydraLib methods like Destroy on window

	window.Name = config.Name or "Hydra UI"
	window.Size = config.Size or UDim2.new(0, 450, 0, 400)
	window.Position = config.Position
	window._tabs = {}
	window._tabButtons = {}
	window._contentPages = {}
	window._activeTabName = nil
	window._closeCallback = config.CloseCallback or function() end
	window._baseZIndex = BASE_ZINDEX_COUNTER -- Assign base Z-index for this window
	BASE_ZINDEX_COUNTER += 200 -- Increment global counter significantly for next window
    window._isDraggingWindow = false -- Track drag state per window

	window._screenGui = Instance.new("ScreenGui", CoreGui)
	window._screenGui.Name = "HydraLib_" .. window.Name:gsub("%s+", "")
	window._screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Use Sibling mode
	window._screenGui.DisplayOrder = window._baseZIndex -- Control draw order vs other ScreenGuis
	window._screenGui.ResetOnSpawn = false
	table.insert(HydraLib._windows, window) -- Track this window

	window._mainFrame = Instance.new("Frame")
	window._mainFrame.Name = "MainWindow"
	window._mainFrame.Size = window.Size
	window._mainFrame.Position = window.Position or UDim2.new(0.5, -window.Size.X.Offset / 2, 0.5, -window.Size.Y.Offset / 2)
	window._mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
	window._mainFrame.BorderSizePixel = 0
	window._mainFrame.ClipsDescendants = true -- Main window should clip contents
	window._mainFrame.Active = false -- Main frame doesn't need to capture input itself
	window._mainFrame.Visible = true
	window._mainFrame.Parent = window._screenGui
	window._mainFrame.ZIndex = window._baseZIndex -- Base Z for window elements
	local mainCorner = Instance.new("UICorner", window._mainFrame)
	mainCorner.CornerRadius = UDim.new(0, 12)

	local titleBar = Instance.new("Frame")
	titleBar.Name = "TitleBar"
	titleBar.Size = UDim2.new(1, 0, 0, 30)
	titleBar.Position = UDim2.new(0, 0, 0, 0)
	titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	titleBar.BorderSizePixel = 0
	titleBar.Active = true -- TitleBar MUST be active for dragging
	titleBar.Parent = window._mainFrame
	titleBar.ZIndex = window._baseZIndex + 10 -- Higher than other window elements for input priority
	local titleCorner = Instance.new("UICorner", titleBar)
	titleCorner.CornerRadius = UDim.new(0, 12)

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleText"
	titleLabel.Size = UDim2.new(1, -40, 1, 0)
	titleLabel.Position = UDim2.new(0, 10, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Text = window.Name
	titleLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
	titleLabel.TextSize = 16
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = titleBar
	titleLabel.ZIndex = titleBar.ZIndex + 1 -- Above title bar background

	-- Dragging Logic Variables (local to MakeWindow)
	local windowDragStart = nil
	local windowStartPos = nil
	local windowDragMoveConnection = nil
	local windowDragReleaseConnection = nil

	local function cleanupWindowDrag()
		if windowDragMoveConnection then windowDragMoveConnection:Disconnect(); windowDragMoveConnection = nil end
		if windowDragReleaseConnection then windowDragReleaseConnection:Disconnect(); windowDragReleaseConnection = nil end
        -- Reset window drag state
        if window then window._isDraggingWindow = false end
	end

	titleBar.InputBegan:Connect(function(input)
        -- Check if window object still exists
        if not window or not window._mainFrame then return end

		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not window._isDraggingWindow then
			window._isDraggingWindow = true
			windowDragStart = input.Position
			windowStartPos = window._mainFrame.Position

			cleanupWindowDrag() -- Disconnect previous connections if they somehow exist

			-- Use UserInputService for global tracking during drag
			windowDragMoveConnection = UserInputService.InputChanged:Connect(function(moveInput)
				if window and window._isDraggingWindow and (moveInput.UserInputType == Enum.UserInputType.MouseMovement or moveInput.UserInputType == Enum.UserInputType.Touch) then
					-- Ensure mainframe still exists before trying to move it
					if window._mainFrame and window._mainFrame.Parent then
						local delta = moveInput.Position - windowDragStart
						window._mainFrame.Position = UDim2.new(windowStartPos.X.Scale, windowStartPos.X.Offset + delta.X, windowStartPos.Y.Scale, windowStartPos.Y.Offset + delta.Y)
					else
						-- Main frame was destroyed during drag, stop dragging
						cleanupWindowDrag()
					end
				end
			end)

			windowDragReleaseConnection = UserInputService.InputEnded:Connect(function(endInput)
				if window and window._isDraggingWindow and (endInput.UserInputType == Enum.UserInputType.MouseButton1 or endInput.UserInputType == Enum.UserInputType.Touch) then
					-- Disconnect listeners immediately on release
					cleanupWindowDrag()
				end
			end)
		end
	end)

	-- Clean up drag listeners if the title bar is destroyed
	titleBar.Destroying:Connect(cleanupWindowDrag)

	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 20, 0, 20)
	closeButton.Position = UDim2.new(1, -25, 0.5, -10)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	closeButton.BorderSizePixel = 0
	closeButton.Font = Enum.Font.SourceSansBold
	closeButton.Text = "X"
	closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	closeButton.TextSize = 14
	closeButton.AutoButtonColor = false
	closeButton.Parent = titleBar
	closeButton.ZIndex = titleBar.ZIndex + 1 -- Above title bar background
	local closeCorner = Instance.new("UICorner", closeButton)
	closeCorner.CornerRadius = UDim.new(0, 4)
	closeButton.MouseButton1Click:Connect(function()
        -- Check window exists before calling destroy
        if window and window.Destroy then
		    window:Destroy() -- Call the window's own destroy method
        end
	end)

	window._tabContainer = Instance.new("Frame")
	window._tabContainer.Name = "TabContainer"
	window._tabContainer.Size = UDim2.new(1, 0, 0, 35)
	window._tabContainer.Position = UDim2.new(0, 0, 0, titleBar.Size.Y.Offset)
	window._tabContainer.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
	window._tabContainer.BorderSizePixel = 0
	window._tabContainer.Active = false -- Doesn't need input
	window._tabContainer.Parent = window._mainFrame
	window._tabContainer.ZIndex = window._baseZIndex + 1 -- Above main frame background
	local tabListLayout = Instance.new("UIListLayout", window._tabContainer)
	tabListLayout.FillDirection = Enum.FillDirection.Horizontal
	tabListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	tabListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	tabListLayout.Padding = UDim.new(0, 5)
	local tabPadding = Instance.new("UIPadding", window._tabContainer)
	tabPadding.PaddingLeft = UDim.new(0, 5)
	tabPadding.PaddingRight = UDim.new(0, 5)

	window._contentContainer = Instance.new("Frame")
	window._contentContainer.Name = "ContentContainer"
	window._contentContainer.Size = UDim2.new(1, -10, 1, -(titleBar.Size.Y.Offset + window._tabContainer.Size.Y.Offset + 5))
	window._contentContainer.Position = UDim2.new(0, 5, 0, titleBar.Size.Y.Offset + window._tabContainer.Size.Y.Offset)
	window._contentContainer.BackgroundTransparency = 1
	window._contentContainer.BorderSizePixel = 0
	window._contentContainer.ClipsDescendants = true -- Content area should clip its children (tab pages)
	window._contentContainer.Active = false -- Doesn't need input itself
	window._contentContainer.Parent = window._mainFrame
	window._contentContainer.ZIndex = window._baseZIndex + 1 -- Above main frame background

	-- Internal function to switch tabs
	function window:_switchTab(targetTabName)
        -- Ensure window and necessary components exist
		if not window or not window._tabButtons or not window._contentPages then return end
		if window._activeTabName == targetTabName then return end -- Don't switch if already active

		-- Ensure the target tab actually exists
		local targetButton = window._tabButtons[targetTabName]
        local targetPage = window._contentPages[targetTabName]
		if not targetButton or not targetPage then
			warn("HydraLib: Attempted to switch to non-existent tab:", targetTabName)
			-- Optionally switch to the first available tab if the target is invalid
			if #window._tabs > 0 then
                 -- Find the first valid tab in the list
                 local firstValidTabName = nil
                 for _, tabObj in ipairs(window._tabs) do
                     if window._tabButtons[tabObj.Name] and window._contentPages[tabObj.Name] then
                         firstValidTabName = tabObj.Name
                         break
                     end
                 end
                 if firstValidTabName and window._activeTabName ~= firstValidTabName then
                     self:_switchTab(firstValidTabName) -- Use self:_switchTab
                 else
                     window._activeTabName = nil -- No valid tabs found
                 end
			else
				window._activeTabName = nil -- No tabs left
			end
			return
		end

		window._activeTabName = targetTabName

		-- Update visual state of all tab buttons and content pages
		for tabName, button in pairs(window._tabButtons) do
            -- Ensure button still exists
            if not button or not button.Parent then goto continue end -- Skip if destroyed

			local contentPage = window._contentPages[tabName]
			local isActive = (tabName == targetTabName)

			-- Update button appearance
			local targetColor = isActive and Color3.fromRGB(0, 120, 255) or Color3.fromRGB(55, 55, 55)
			local targetTextColor = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(180, 180, 180)

            -- Check if button still exists before tweening
            if button and button.Parent then
			    TweenService:Create(button, TweenInfo.new(0.2), { BackgroundColor3 = targetColor }):Play()
            end
			local textLabel = button:FindFirstChild("TextLabel")
			if textLabel and textLabel.Parent then -- Check if label exists
				TweenService:Create(textLabel, TweenInfo.new(0.2), { TextColor3 = targetTextColor }):Play()
			end

			-- Update content page visibility
			if contentPage and contentPage.Parent then -- Check if page exists
				contentPage.Visible = isActive
				if isActive then
					-- Reset scroll position when tab becomes visible for better UX
					contentPage.CanvasPosition = Vector2.new()
				end
			end

            ::continue::
		end
	end

	return window
end


function HydraLib:MakeTab(config)
	config = config or {}
	local window = self
	if not window or not window._mainFrame or not window._mainFrame.Parent then
		error("HydraLib Error: MakeTab must be called on a valid Window object.", 2)
		return
	end

	local tab = {}
	tab.Name = config.Name or "Tab " .. (#window._tabs + 1) -- More readable default name
	tab._window = window
	tab._layoutOrderCounter = 1 -- Counter for elements within this tab

	-- Check for duplicate tab names
	if window._tabButtons[tab.Name] then
		warn("HydraLib Warning: Duplicate tab name '" .. tab.Name .. "'. Overwriting existing tab references.")
		-- Note: This doesn't destroy the old tab's elements, just makes the button/page inaccessible via this name.
        -- Proper handling might involve destroying the old tab first or preventing duplicates.
	end

	local tabButton = Instance.new("TextButton")
	tabButton.Name = tab.Name .. "TabButton"
	tabButton.Size = UDim2.new(0, 100, 0, 25) -- Fixed width, adjust as needed or use TextService:GetTextSize
	tabButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55) -- Initial inactive color
	tabButton.BorderSizePixel = 0
	tabButton.LayoutOrder = #window._tabs + 1
	tabButton.Parent = window._tabContainer
	tabButton.AutoButtonColor = false
	tabButton.ZIndex = window._tabContainer.ZIndex + 1 -- Above tab container background
	local tabCorner = Instance.new("UICorner", tabButton)
	tabCorner.CornerRadius = UDim.new(0, 6)

	local tabTextLabel = Instance.new("TextLabel", tabButton)
	tabTextLabel.Name = "TextLabel"
	tabTextLabel.Size = UDim2.new(1, 0, 1, 0)
	tabTextLabel.BackgroundTransparency = 1
	tabTextLabel.Text = tab.Name
	tabTextLabel.TextColor3 = Color3.fromRGB(180, 180, 180) -- Initial inactive color
	tabTextLabel.Font = Enum.Font.GothamSemibold
	tabTextLabel.TextSize = 14
	tabTextLabel.ZIndex = tabButton.ZIndex + 1 -- Above button background

	window._tabButtons[tab.Name] = tabButton

	tab._contentPage = Instance.new("ScrollingFrame")
	tab._contentPage.Name = tab.Name .. "ContentPage"
	tab._contentPage.Size = UDim2.new(1, 0, 1, 0) -- Fill the content container
	tab._contentPage.Position = UDim2.new(0, 0, 0, 0)
	tab._contentPage.BackgroundTransparency = 1
	tab._contentPage.BorderSizePixel = 0
	tab._contentPage.Visible = false -- Initially hidden
	tab._contentPage.ClipsDescendants = false -- ScrollingFrame itself shouldn't clip its children unless necessary for scrollbar
	tab._contentPage.Parent = window._contentContainer
	tab._contentPage.CanvasSize = UDim2.new(0, 0, 0, 0) -- Start at 0, AutoSize Y handles this
	tab._contentPage.ScrollBarThickness = 6
	tab._contentPage.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
	tab._contentPage.ScrollingDirection = Enum.ScrollingDirection.Y
	tab._contentPage.AutomaticCanvasSize = Enum.AutomaticSize.Y -- Let layout determine height needed
	tab._contentPage.CanvasPosition = Vector2.new()
	tab._contentPage.ZIndex = window._contentContainer.ZIndex + 1 -- Above content container background

	local contentPadding = Instance.new("UIPadding", tab._contentPage)
	contentPadding.PaddingTop = UDim.new(0, 10)
	contentPadding.PaddingBottom = UDim.new(0, 10)
	contentPadding.PaddingLeft = UDim.new(0, 10)
	contentPadding.PaddingRight = UDim.new(0, 10)

	tab._contentLayout = Instance.new("UIListLayout", tab._contentPage)
	tab._contentLayout.Padding = UDim.new(0, 15) -- Spacing between elements
	tab._contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
	tab._contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left

	window._contentPages[tab.Name] = tab._contentPage
	table.insert(window._tabs, tab)

	-- Define element adder methods directly on this tab object
	tab.AddSlider = function(self, sliderConfig)
		if not self or not self._contentPage or not self._contentPage.Parent then error("HydraLib Error: Slider cannot be added to a destroyed or invalid tab.", 2) end
		sliderConfig = sliderConfig or {}
		sliderConfig._LayoutOrder = self._layoutOrderCounter
		self._layoutOrderCounter = self._layoutOrderCounter + 1
		local element, setter = _createSlider(self._contentPage, sliderConfig)
		return { Type = "Slider", Element = element, Set = setter }
	end

	tab.AddToggle = function(self, toggleConfig)
		if not self or not self._contentPage or not self._contentPage.Parent then error("HydraLib Error: Toggle cannot be added to a destroyed or invalid tab.", 2) end
		toggleConfig = toggleConfig or {}
		toggleConfig._LayoutOrder = self._layoutOrderCounter
		self._layoutOrderCounter = self._layoutOrderCounter + 1
		local element, setter = _createToggle(self._contentPage, toggleConfig)
		return { Type = "Toggle", Element = element, Set = setter }
	end

	tab.AddDropdown = function(self, dropdownConfig)
		if not self or not self._contentPage or not self._contentPage.Parent then error("HydraLib Error: Dropdown cannot be added to a destroyed or invalid tab.", 2) end
		dropdownConfig = dropdownConfig or {}
		dropdownConfig._LayoutOrder = self._layoutOrderCounter
		self._layoutOrderCounter = self._layoutOrderCounter + 1
        -- Ensure window and screenGui still exist
        if not self._window or not self._window._screenGui or not self._window._screenGui.Parent then
             error("HydraLib Error: Cannot add Dropdown because the parent window or ScreenGui is invalid.", 2)
        end
		local dropdownBaseZ = self._window._baseZIndex + 20 -- Base Z for dropdown container
		local element, setter, refresher = _createDropdown(self._contentPage, dropdownConfig, self._window._screenGui, dropdownBaseZ)
		return { Type = "Dropdown", Element = element, Set = setter, Refresh = refresher }
	end

	-- Connect the button click to the window's tab switching function
	tabButton.MouseButton1Click:Connect(function()
		-- Ensure window still exists and has the method before switching
		if window and type(window._switchTab) == "function" then
			window:_switchTab(tab.Name)
		end
	end)

	-- Activate the first tab automatically if it's the only one
	if #window._tabs == 1 then
        -- Use task.defer to ensure everything is set up before switching, check window exists
        task.defer(function()
            if window and type(window._switchTab) == "function" then
                 window:_switchTab(window, tab.Name) -- Pass window object as first arg (self)
            end
        end)
	end

	return tab
end

--==============================================================================--
--                             LIBRARY UTILITIES                                --
--==============================================================================--

function HydraLib:Destroy()
	if self == HydraLib then
		-- Static call: Destroy ALL tracked windows
		-- Iterate backwards because Destroy modifies the table
		for i = #HydraLib._windows, 1, -1 do
			local window = HydraLib._windows[i]
			if type(window) == "table" and type(window.Destroy) == "function" then
				pcall(window.Destroy, window) -- Call Destroy method *on the window object itself*
			else
                 table.remove(HydraLib._windows, i) -- Remove invalid entry
            end
		end
		HydraLib._windows = {} -- Clear the tracking table completely
		BASE_ZINDEX_COUNTER = 1 -- Reset global Z-index counter
	else
		-- Instance call: Destroy THIS specific window object
		local window = self
        -- Check if already destroyed or invalid
		if not window or not window._screenGui or not window._screenGui.Parent then return end

		-- Remove this window from the global tracking table *first*
		for i, w in ipairs(HydraLib._windows) do
			if w == window then
				table.remove(HydraLib._windows, i)
				break
			end
		end

		-- Safely call user-defined close callback
		pcall(window._closeCallback)

        -- If dragging window when destroyed, clean up listeners
        if window._isDraggingWindow then
            -- Access the drag connections (might need to store them on window object, or rely on Destroying signals)
            -- Simpler: Destroying the TitleBar (descendant of ScreenGui) should trigger its cleanup.
        end

		-- Destroy the ScreenGui, which removes all descendants and disconnects their signals
		window._screenGui:Destroy()

		-- Nil out fields to help garbage collection and prevent use-after-destroy errors
		for k, _ in pairs(window) do
			window[k] = nil
		end
		-- Break metatable link
		setmetatable(window, nil)
	end
end

-- Expose the main library object
return HydraLib
