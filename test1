--[[
	Hydra UI Library
	A simple, modern UI library inspired by the structure of OrionLib.
	Features:
		- Draggable Window
		- Tabs
		- Sliders
		- Toggles (Checkboxes)
		- Dropdowns
--]]

local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService") -- Needed for reliable AbsoluteSize/Pos

local HydraLib = {}
HydraLib.__index = HydraLib
HydraLib._windows = {} -- Keep track of created windows

local ZINDEX_COUNTER = 1 -- Simple way to manage base ZIndex for multiple windows/dropdowns

--==============================================================================--
--                           INTERNAL HELPER FUNCTIONS                          --
--==============================================================================--
-- These functions are internal to the library and create the actual GUI elements.

local function _createSlider(parent, config)
	local minValue = config.Min or 0
	local maxValue = config.Max or 100
	local initialValue = math.clamp(config.Default or minValue, minValue, maxValue)
	local label = config.Name or "Slider"
	local valueName = config.ValueName or ""
	local increment = config.Increment or 1 -- Affects snapping/rounding
    local callback = config.Callback or function() end

	local container = Instance.new("Frame")
	container.Name = label:gsub("%s+", "") .. "SliderContainer"
	container.Size = UDim2.new(1, 0, 0, 45)
	container.BackgroundTransparency = 1
	container.Parent = parent
    container.LayoutOrder = config._LayoutOrder or 0

	local SliderLabel = Instance.new("TextLabel", container)
	SliderLabel.Size = UDim2.new(1, 0, 0, 15)
	SliderLabel.Position = UDim2.new(0, 0, 0, 0)
	SliderLabel.BackgroundTransparency = 1
	SliderLabel.Font = Enum.Font.Gotham
	SliderLabel.TextSize = 14
	SliderLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	SliderLabel.TextXAlignment = Enum.TextXAlignment.Left

	local SliderFrame = Instance.new("Frame", container)
	SliderFrame.Name = "SliderTrack"
	SliderFrame.Size = UDim2.new(1, 0, 0, 10)
	SliderFrame.Position = UDim2.new(0, 0, 0, 20)
	SliderFrame.BackgroundColor3 = config.TrackColor or Color3.fromRGB(50, 50, 50)
	SliderFrame.BorderSizePixel = 0
	SliderFrame.Active = true
	local SliderCorner = Instance.new("UICorner", SliderFrame)
	SliderCorner.CornerRadius = UDim.new(0, 5)

	local Fill = Instance.new("Frame", SliderFrame)
	Fill.Name = "SliderFill"
	Fill.BackgroundColor3 = config.Color or Color3.fromRGB(0, 120, 255)
	Fill.BorderSizePixel = 0
	local FillCorner = Instance.new("UICorner", Fill)
	FillCorner.CornerRadius = UDim.new(0, 5)

	local currentSliderValue = initialValue
	local isDraggingSlider = false
	local dragMoveConnection = nil
	local dragReleaseConnection = nil

	local function updateSliderDisplay(ratio, triggerCallback)
        ratio = math.clamp(ratio, 0, 1)
		local range = maxValue - minValue
		local rawValue = minValue + ratio * range
        local steppedValue = math.floor(rawValue / increment + 0.5) * increment -- Apply increment stepping
		local finalValue = math.clamp(steppedValue, minValue, maxValue) -- Clamp again after stepping
		local displayRatio = math.clamp((finalValue - minValue) / range, 0, 1)

        if finalValue ~= currentSliderValue or triggerCallback == "force" then
            currentSliderValue = finalValue
            TweenService:Create(Fill, TweenInfo.new(0.05), {Size = UDim2.new(displayRatio, 0, 1, 0)}):Play()
            SliderLabel.Text = label .. ": " .. string.format("%.f", currentSliderValue) .. (valueName ~= "" and " " .. valueName or "") -- Use %.f for integer display
            if triggerCallback then
                task.spawn(callback, currentSliderValue)
            end
        end
	end

	local function calculateRatioFromInput(input)
		-- Wait a frame to ensure AbsolutePosition/Size are up-to-date
        RunService.Heartbeat:Wait()
        local frameAbsPos = SliderFrame.AbsolutePosition
		local frameAbsSize = SliderFrame.AbsoluteSize
		local relativeX = input.Position.X - frameAbsPos.X
		local totalWidth = frameAbsSize.X
		if totalWidth <= 0 then return (currentSliderValue - minValue) / (maxValue - minValue) end -- Avoid division by zero
		return math.clamp(relativeX / totalWidth, 0, 1)
	end

	SliderFrame.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not isDraggingSlider then
			isDraggingSlider = true
			updateSliderDisplay(calculateRatioFromInput(input), true) -- Update and trigger callback on initial click

			if dragMoveConnection then dragMoveConnection:Disconnect() end
			if dragReleaseConnection then dragReleaseConnection:Disconnect() end

			dragMoveConnection = UserInputService.InputChanged:Connect(function(moveInput)
				if isDraggingSlider and (moveInput.UserInputType == Enum.UserInputType.MouseMovement or moveInput.UserInputType == Enum.UserInputType.Touch) then
					updateSliderDisplay(calculateRatioFromInput(moveInput), false) -- Update display only while dragging
				end
			end)

			dragReleaseConnection = UserInputService.InputEnded:Connect(function(endInput)
				if isDraggingSlider and (endInput.UserInputType == Enum.UserInputType.MouseButton1 or endInput.UserInputType == Enum.UserInputType.Touch) then
					isDraggingSlider = false
					updateSliderDisplay(calculateRatioFromInput(endInput), true) -- Final update and trigger callback on release
					if dragMoveConnection then dragMoveConnection:Disconnect(); dragMoveConnection = nil end
					if dragReleaseConnection then dragReleaseConnection:Disconnect(); dragReleaseConnection = nil end
				end
			end)
		end
	end)

	updateSliderDisplay((initialValue - minValue) / (maxValue - minValue), "force") -- Initial setup without callback
	return container, function(newValue) -- Return setter function
		local newRatio = math.clamp((newValue - minValue) / (maxValue - minValue), 0, 1)
		updateSliderDisplay(newRatio, false) -- Update display without triggering callback
	end
end

local function _createToggle(parent, config)
	local labelText = config.Name or "Toggle"
	local initialValue = config.Default or false
    local callback = config.Callback or function() end
	local toggled = initialValue

	local toggleHeight = 25
	local checkboxSize = 18
	local spacing = 8

	local Container = Instance.new("Frame")
	Container.Name = labelText:gsub("%s+", "") .. "ToggleContainer"
	Container.Size = UDim2.new(1, 0, 0, toggleHeight)
	Container.BackgroundTransparency = 1
	Container.Parent = parent
    Container.LayoutOrder = config._LayoutOrder or 0

	local Label = Instance.new("TextLabel")
	Label.Name = "Label"
	Label.Size = UDim2.new(1, -(checkboxSize + spacing), 1, 0)
	Label.Position = UDim2.new(0, 0, 0, 0)
	Label.BackgroundTransparency = 1
	Label.Font = Enum.Font.Gotham
	Label.Text = labelText
	Label.TextColor3 = Color3.fromRGB(220, 220, 220)
	Label.TextSize = 16
	Label.TextXAlignment = Enum.TextXAlignment.Left
	Label.TextYAlignment = Enum.TextYAlignment.Center
	Label.Parent = Container

	local CheckboxFrame = Instance.new("Frame")
	CheckboxFrame.Name = "CheckboxFrame"
	CheckboxFrame.Size = UDim2.new(0, checkboxSize, 0, checkboxSize)
	CheckboxFrame.Position = UDim2.new(1, -checkboxSize, 0.5, -checkboxSize / 2)
	CheckboxFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	CheckboxFrame.BorderSizePixel = 1
	CheckboxFrame.BorderColor3 = Color3.fromRGB(90, 90, 90)
	CheckboxFrame.Parent = Container
	local CheckboxCorner = Instance.new("UICorner", CheckboxFrame)
	CheckboxCorner.CornerRadius = UDim.new(0, 4)

	local Checkmark = Instance.new("Frame", CheckboxFrame)
	Checkmark.Name = "Checkmark"
	Checkmark.Size = UDim2.new(0.7, 0, 0.7, 0)
	Checkmark.Position = UDim2.new(0.5, 0, 0.5, 0)
	Checkmark.AnchorPoint = Vector2.new(0.5, 0.5)
	Checkmark.BackgroundColor3 = config.Color or Color3.fromRGB(0, 180, 90)
	Checkmark.BorderSizePixel = 0
	Checkmark.BackgroundTransparency = toggled and 0 or 1
	local CheckmarkCorner = Instance.new("UICorner", Checkmark)
	CheckmarkCorner.CornerRadius = UDim.new(0, 3)

	local ClickButton = Instance.new("TextButton", Container)
	ClickButton.Name = "ClickArea"
	ClickButton.Size = UDim2.new(1, 0, 1, 0)
	ClickButton.BackgroundTransparency = 1
	ClickButton.Text = ""
	ClickButton.ZIndex = 2

    local function updateVisuals(state)
		TweenService:Create(Checkmark, TweenInfo.new(0.15), { BackgroundTransparency = state and 0 or 1 }):Play()
		TweenService:Create(CheckboxFrame, TweenInfo.new(0.15), { BackgroundColor3 = state and Color3.fromRGB(70, 70, 70) or Color3.fromRGB(60, 60, 60) }):Play()
    end

	ClickButton.MouseButton1Click:Connect(function()
		toggled = not toggled
        updateVisuals(toggled)
		task.spawn(callback, toggled)
	end)

    updateVisuals(toggled) -- Set initial visual state

	return Container, function(newState) -- Return setter function
        if type(newState) == "boolean" and newState ~= toggled then
            toggled = newState
            updateVisuals(toggled)
            -- Optional: Decide if setting programmatically should trigger the callback
            -- task.spawn(callback, toggled)
        end
	end
end

local function _createDropdown(parent, config, screenGuiRef) -- Need ScreenGui for dismiss button
	local labelText = config.Name or "Dropdown"
	local options = config.Options or {"Option 1"}
	local defaultOption = config.Default
    local callback = config.Callback or function() end

    local selectedIndex = 1
    if defaultOption then
        for i, v in ipairs(options) do
            if v == defaultOption then
                selectedIndex = i
                break
            end
        end
    end
	local selectedOptionText = options[selectedIndex] or "Select..."
	local isOpen = false

	local dropdownBaseHeight = 30
    local labelHeight = 18
	local totalControlHeight = dropdownBaseHeight + labelHeight
	local optionsVisibleHeight = 100
	local optionHeight = 25

	local Container = Instance.new("Frame")
	Container.Name = labelText:gsub("%s+", "") .. "DropdownContainer"
	Container.Size = UDim2.new(1, 0, 0, totalControlHeight)
	Container.BackgroundTransparency = 1
	Container.ClipsDescendants = false -- Important: Must be false initially
	Container.Parent = parent
    Container.LayoutOrder = config._LayoutOrder or 0
	Container.ZIndex = ZINDEX_COUNTER * 2 -- Base ZIndex for dropdown

	local Label = Instance.new("TextLabel")
	Label.Name = "Label"
	Label.Size = UDim2.new(1, 0, 0, labelHeight)
	Label.Position = UDim2.new(0, 0, 0, 0)
	Label.BackgroundTransparency = 1
	Label.Font = Enum.Font.Gotham
	Label.Text = labelText
	Label.TextColor3 = Color3.fromRGB(200, 200, 200)
	Label.TextSize = 14
	Label.TextXAlignment = Enum.TextXAlignment.Left
	Label.TextYAlignment = Enum.TextYAlignment.Bottom
	Label.Parent = Container

	local DisplayButton = Instance.new("TextButton")
	DisplayButton.Name = "DisplayButton"
	DisplayButton.Size = UDim2.new(1, 0, 0, dropdownBaseHeight)
	DisplayButton.Position = UDim2.new(0, 0, 0, labelHeight)
	DisplayButton.BackgroundColor3 = config.Color or Color3.fromRGB(55, 55, 55)
	DisplayButton.Font = Enum.Font.GothamSemibold
	DisplayButton.Text = selectedOptionText .. " ▼"
	DisplayButton.TextColor3 = Color3.fromRGB(210, 210, 210)
	DisplayButton.TextSize = 14
	DisplayButton.TextXAlignment = Enum.TextXAlignment.Left
	DisplayButton.Parent = Container
	local DisplayCorner = Instance.new("UICorner", DisplayButton)
	DisplayCorner.CornerRadius = UDim.new(0, 6)
	local DisplayPadding = Instance.new("UIPadding", DisplayButton)
	DisplayPadding.PaddingLeft = UDim.new(0, 8)
	DisplayPadding.PaddingRight = UDim.new(0, 8)

	local OptionsFrame = Instance.new("ScrollingFrame")
	OptionsFrame.Name = "OptionsFrame"
	OptionsFrame.Size = UDim2.new(1, 0, 0, 0) -- Calculated later
	OptionsFrame.Position = UDim2.new(0, 0, 1, 2) -- Below display button
    OptionsFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	OptionsFrame.BorderSizePixel = 1
	OptionsFrame.BorderColor3 = Color3.fromRGB(70, 70, 70)
	OptionsFrame.Visible = false
	OptionsFrame.ClipsDescendants = true
	OptionsFrame.Parent = Container -- Parent to container
	OptionsFrame.ZIndex = ZINDEX_COUNTER * 10 -- Higher ZIndex for options
	OptionsFrame.ScrollBarThickness = 5
	OptionsFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
	OptionsFrame.ScrollingDirection = Enum.ScrollingDirection.Y
	local OptionsCorner = Instance.new("UICorner", OptionsFrame)
	OptionsCorner.CornerRadius = UDim.new(0, 6)
	local OptionsLayout = Instance.new("UIListLayout", OptionsFrame)
	OptionsLayout.SortOrder = Enum.SortOrder.LayoutOrder
	OptionsLayout.Padding = UDim.new(0, 2)
	local OptionsPadding = Instance.new("UIPadding", OptionsFrame)
	OptionsPadding.PaddingTop = UDim.new(0, 4)
	OptionsPadding.PaddingBottom = UDim.new(0, 4)
	OptionsPadding.PaddingLeft = UDim.new(0, 4)
	OptionsPadding.PaddingRight = UDim.new(0, 4)

	local currentDismissButton = nil
    local currentDismissConn = nil

	local function closeDropdown(triggerCallback, newIndex, newText)
        if not isOpen then return end -- Already closed

        selectedIndex = newIndex or selectedIndex
        selectedOptionText = newText or selectedOptionText
        DisplayButton.Text = selectedOptionText .. " ▼"
        isOpen = false
        OptionsFrame.Visible = false
        Container.ZIndex = ZINDEX_COUNTER * 2 -- Reset ZIndex
        Container.ClipsDescendants = false -- Allow overflow again if needed by siblings

        if currentDismissButton and currentDismissButton.Parent then
            currentDismissButton:Destroy()
            currentDismissButton = nil
        end
        if currentDismissConn then
            currentDismissConn:Disconnect()
            currentDismissConn = nil
        end

        if triggerCallback then
             task.spawn(callback, selectedOptionText)
        end
	end

	local function selectOption(index, optionText)
        closeDropdown(true, index, optionText) -- Close and trigger callback
	end

    local function buildOptions()
        -- Clear existing options
        for _, child in ipairs(OptionsFrame:GetChildren()) do
            if child:IsA("TextButton") then
                child:Destroy()
            end
        end

        -- Populate options
        for index, optionText in ipairs(options) do
            local OptionButton = Instance.new("TextButton")
            OptionButton.Name = "Option_" .. index
            OptionButton.Size = UDim2.new(1, 0, 0, optionHeight)
            OptionButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
            OptionButton.BackgroundTransparency = 0.5
            OptionButton.BorderSizePixel = 0
            OptionButton.Font = Enum.Font.Gotham
            OptionButton.Text = optionText
            OptionButton.TextColor3 = Color3.fromRGB(200, 200, 200)
            OptionButton.TextSize = 14
            OptionButton.LayoutOrder = index
            OptionButton.Parent = OptionsFrame

            OptionButton.MouseEnter:Connect(function() TweenService:Create(OptionButton, TweenInfo.new(0.1), {BackgroundTransparency = 0.2}):Play() end)
            OptionButton.MouseLeave:Connect(function() TweenService:Create(OptionButton, TweenInfo.new(0.1), {BackgroundTransparency = 0.5}):Play() end)

            OptionButton.MouseButton1Click:Connect(function()
                selectOption(index, optionText)
            end)
        end

        -- Calculate options frame height
        local totalContentHeight = (#options * optionHeight) + math.max(0, #options - 1) * OptionsLayout.Padding.Offset + OptionsPadding.PaddingTop.Offset + OptionsPadding.PaddingBottom.Offset
        local optionsFrameVisibleHeight = math.min(totalContentHeight, optionsVisibleHeight)
        OptionsFrame.Size = UDim2.new(1, 0, 0, optionsFrameVisibleHeight)
        OptionsFrame.CanvasSize = UDim2.new(0, 0, 0, totalContentHeight)
    end

	DisplayButton.MouseButton1Click:Connect(function()
		if isOpen then
            closeDropdown(false) -- Just close, don't trigger callback
        else
            -- Open
            isOpen = true
            OptionsFrame.Visible = true
            DisplayButton.Text = selectedOptionText .. " ▲"
            Container.ZIndex = ZINDEX_COUNTER * 11 -- Bring container to front
            Container.ClipsDescendants = true -- Clip options frame while open

            -- Create dismiss button
            if currentDismissButton and currentDismissButton.Parent then currentDismissButton:Destroy() end -- Clean up old one just in case
            if currentDismissConn then currentDismissConn:Disconnect() end

            currentDismissButton = Instance.new("TextButton")
            currentDismissButton.Name = "HydraDismissDropdown"
            currentDismissButton.Size = UDim2.new(1, 0, 1, 0)
            currentDismissButton.Position = UDim2.new(0,0,0,0)
            currentDismissButton.BackgroundTransparency = 1
            currentDismissButton.Text = ""
            currentDismissButton.ZIndex = ZINDEX_COUNTER * 9 -- Below options, above others
            currentDismissButton.Parent = screenGuiRef -- Parent to the ScreenGui

            currentDismissConn = currentDismissButton.MouseButton1Click:Connect(function()
                -- Check if click was outside the dropdown components
                local mousePos = UserInputService:GetMouseLocation()
                RunService.Heartbeat:Wait() -- Ensure AbsolutePos/Size are updated

                local optionsAbsPos = OptionsFrame.AbsolutePosition
                local optionsAbsSize = OptionsFrame.AbsoluteSize
                local isOverOptions = mousePos.X >= optionsAbsPos.X and mousePos.X <= optionsAbsPos.X + optionsAbsSize.X and
                                     mousePos.Y >= optionsAbsPos.Y and mousePos.Y <= optionsAbsPos.Y + optionsAbsSize.Y

                local displayAbsPos = DisplayButton.AbsolutePosition
                local displayAbsSize = DisplayButton.AbsoluteSize
                local isOverDisplay = mousePos.X >= displayAbsPos.X and mousePos.X <= displayAbsPos.X + displayAbsSize.X and
                                      mousePos.Y >= displayAbsPos.Y and mousePos.Y <= displayAbsPos.Y + displayAbsSize.Y

                if not isOverOptions and not isOverDisplay then
                    closeDropdown(false) -- Clicked outside, close without triggering callback
                end
            end)
        end
	end)

    buildOptions() -- Initial population

    -- Return setter and refresher functions
    local function setOption(optionValue)
        local found = false
        for i, v in ipairs(options) do
            if v == optionValue then
                selectedIndex = i
                selectedOptionText = v
                DisplayButton.Text = selectedOptionText .. (isOpen and " ▲" or " ▼")
                found = true
                break
            end
        end
        -- Optional: Decide if setting programmatically triggers callback
        -- if found then task.spawn(callback, selectedOptionText) end
        return found -- Indicate if setting was successful
    end

    local function refreshOptions(newOptions, clearCurrentSelection)
        options = newOptions or {}
        if clearCurrentSelection or selectedIndex > #options then
            selectedIndex = 1
        end
        selectedOptionText = options[selectedIndex] or "Select..."
        DisplayButton.Text = selectedOptionText .. (isOpen and " ▲" or " ▼")
        buildOptions()
        -- Optional: Trigger callback if selection changed due to refresh
        -- task.spawn(callback, selectedOptionText)
    end

	return Container, setOption, refreshOptions
end

--==============================================================================--
--                             LIBRARY MAIN METHODS                             --
--==============================================================================--

function HydraLib:MakeWindow(config)
	config = config or {}
	local window = {}
	setmetatable(window, HydraLib) -- Inherit library methods if needed later

	window.Name = config.Name or "Hydra UI"
	window.Size = config.Size or UDim2.new(0, 450, 0, 400)
	window.Position = config.Position -- Will default if nil
    window._tabs = {}
    window._tabButtons = {}
    window._contentPages = {}
    window._activeTabName = nil
    window._closeCallback = config.CloseCallback or function() end
    window._nextLayoutOrder = 1 -- For controls within tabs

	-- Create ScreenGui
	window._screenGui = Instance.new("ScreenGui", CoreGui)
	window._screenGui.Name = "HydraLib_" .. window.Name:gsub("%s+", "")
	window._screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	window._screenGui.ResetOnSpawn = false
    table.insert(HydraLib._windows, window) -- Track the window

    ZINDEX_COUNTER += 20 -- Increment global ZIndex base for next window/dropdown

	-- Create Main Frame (Window)
	window._mainFrame = Instance.new("Frame")
	window._mainFrame.Name = "MainWindow"
	window._mainFrame.Size = window.Size
    window._mainFrame.Position = window.Position or UDim2.new(0.5, -window.Size.X.Offset / 2, 0.5, -window.Size.Y.Offset / 2)
	window._mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
	window._mainFrame.BorderSizePixel = 0
	window._mainFrame.ClipsDescendants = true
	window._mainFrame.Active = true
	window._mainFrame.Visible = true
	window._mainFrame.Parent = window._screenGui
	local mainCorner = Instance.new("UICorner", window._mainFrame)
	mainCorner.CornerRadius = UDim.new(0, 12)

	-- Create Title Bar
	local titleBar = Instance.new("Frame")
	titleBar.Name = "TitleBar"
	titleBar.Size = UDim2.new(1, 0, 0, 30)
	titleBar.Position = UDim2.new(0, 0, 0, 0)
	titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	titleBar.BorderSizePixel = 0
	titleBar.Active = true
	titleBar.Parent = window._mainFrame
	local titleCorner = Instance.new("UICorner", titleBar)
	titleCorner.CornerRadius = UDim.new(0, 12) -- Covers top corners only due to layout
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleText"
	titleLabel.Size = UDim2.new(1, -40, 1, 0) -- Leave space for potential close button
	titleLabel.Position = UDim2.new(0, 10, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Text = window.Name
	titleLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
	titleLabel.TextSize = 16
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = titleBar

	-- Draggable Logic
	local isDraggingWindow = false
	local windowDragStart = nil
	local windowStartPos = nil
	local windowDragMoveConnection = nil
	local windowDragReleaseConnection = nil
	titleBar.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not isDraggingWindow then
			isDraggingWindow = true
			windowDragStart = input.Position
			windowStartPos = window._mainFrame.Position
			if windowDragMoveConnection then windowDragMoveConnection:Disconnect() end
			if windowDragReleaseConnection then windowDragReleaseConnection:Disconnect() end
			windowDragMoveConnection = UserInputService.InputChanged:Connect(function(moveInput)
				if isDraggingWindow and (moveInput.UserInputType == Enum.UserInputType.MouseMovement or moveInput.UserInputType == Enum.UserInputType.Touch) then
					local delta = moveInput.Position - windowDragStart
					window._mainFrame.Position = UDim2.new(windowStartPos.X.Scale, windowStartPos.X.Offset + delta.X, windowStartPos.Y.Scale, windowStartPos.Y.Offset + delta.Y)
				end
			end)
			windowDragReleaseConnection = UserInputService.InputEnded:Connect(function(endInput)
				if isDraggingWindow and (endInput.UserInputType == Enum.UserInputType.MouseButton1 or endInput.UserInputType == Enum.UserInputType.Touch) then
					isDraggingWindow = false
					if windowDragMoveConnection then windowDragMoveConnection:Disconnect(); windowDragMoveConnection = nil end
					if windowDragReleaseConnection then windowDragReleaseConnection:Disconnect(); windowDragReleaseConnection = nil end
				end
			end)
		end
	end)

    -- Optional: Simple Close Button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 20, 0, 20)
    closeButton.Position = UDim2.new(1, -25, 0.5, -10)
    closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    closeButton.BorderSizePixel = 0
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 14
    closeButton.Parent = titleBar
    local closeCorner = Instance.new("UICorner", closeButton)
    closeCorner.CornerRadius = UDim.new(0, 4)
    closeButton.MouseButton1Click:Connect(function()
        window:Destroy() -- Use the window's destroy method
    end)

	-- Create Tab Container
	window._tabContainer = Instance.new("Frame")
	window._tabContainer.Name = "TabContainer"
	window._tabContainer.Size = UDim2.new(1, 0, 0, 35)
	window._tabContainer.Position = UDim2.new(0, 0, 0, titleBar.Size.Y.Offset)
	window._tabContainer.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
	window._tabContainer.BorderSizePixel = 0
	window._tabContainer.Parent = window._mainFrame
	local tabListLayout = Instance.new("UIListLayout", window._tabContainer)
	tabListLayout.FillDirection = Enum.FillDirection.Horizontal
	tabListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	tabListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	tabListLayout.Padding = UDim.new(0, 5)
	local tabPadding = Instance.new("UIPadding", window._tabContainer)
	tabPadding.PaddingLeft = UDim.new(0, 5)
	tabPadding.PaddingRight = UDim.new(0, 5)

	-- Create Content Area Container
	window._contentContainer = Instance.new("Frame")
	window._contentContainer.Name = "ContentContainer"
	window._contentContainer.Size = UDim2.new(1, -10, 1, -(titleBar.Size.Y.Offset + window._tabContainer.Size.Y.Offset + 5))
	window._contentContainer.Position = UDim2.new(0, 5, 0, titleBar.Size.Y.Offset + window._tabContainer.Size.Y.Offset)
	window._contentContainer.BackgroundTransparency = 1
	window._contentContainer.BorderSizePixel = 0
	window._contentContainer.ClipsDescendants = true
	window._contentContainer.Parent = window._mainFrame

    -- Function to switch tabs (internal to the window)
    function window:_switchTab(targetTabName)
        if window._activeTabName == targetTabName then return end
        window._activeTabName = targetTabName
        for tabName, button in pairs(window._tabButtons) do
            local isActive = (tabName == targetTabName)
            local targetColor = isActive and Color3.fromRGB(0, 120, 255) or Color3.fromRGB(55, 55, 55)
            local targetTextColor = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(180, 180, 180)
            TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = targetColor}):Play()
            TweenService:Create(button.TextLabel, TweenInfo.new(0.2), {TextColor3 = targetTextColor}):Play() -- Target TextLabel inside
            if window._contentPages[tabName] then
                 window._contentPages[tabName].Visible = isActive
            end
        end
    end

	return window
end

function HydraLib:MakeTab(config)
	config = config or {}
    local window = self -- Assumes this is called like Window:MakeTab(...)
    if not window or not window._mainFrame then
        error("MakeTab must be called on a Window object created by MakeWindow.")
        return
    end

	local tab = {}
	tab.Name = config.Name or "Tab" .. (#window._tabs + 1)
    tab._window = window -- Reference back to the parent window
    tab._layoutOrderCounter = 1 -- Counter for elements within this tab

	-- Create Tab Button
	local tabButton = Instance.new("TextButton")
	tabButton.Name = tab.Name .. "TabButton"
	tabButton.Size = UDim2.new(0, 100, 0, 25)
	tabButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
	tabButton.BorderSizePixel = 0
	tabButton.LayoutOrder = #window._tabs + 1 -- Position based on creation order
	tabButton.Parent = window._tabContainer
    tabButton.AutoButtonColor = false -- Disable default button color changes
    local tabCorner = Instance.new("UICorner", tabButton)
	tabCorner.CornerRadius = UDim.new(0, 6)

    -- Add TextLabel inside button for better control
    local tabTextLabel = Instance.new("TextLabel", tabButton)
    tabTextLabel.Name = "TextLabel"
    tabTextLabel.Size = UDim2.new(1, 0, 1, 0)
    tabTextLabel.BackgroundTransparency = 1
	tabTextLabel.Text = tab.Name
	tabTextLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
	tabTextLabel.Font = Enum.Font.GothamSemibold
	tabTextLabel.TextSize = 14

	window._tabButtons[tab.Name] = tabButton -- Store button reference

	-- Create Content Page Frame (ScrollingFrame)
	tab._contentPage = Instance.new("ScrollingFrame")
	tab._contentPage.Name = tab.Name .. "ContentPage"
	tab._contentPage.Size = UDim2.new(1, 0, 1, 0)
	tab._contentPage.Position = UDim2.new(0, 0, 0, 0)
	tab._contentPage.BackgroundTransparency = 1
	tab._contentPage.BorderSizePixel = 0
	tab._contentPage.Visible = false -- Initially hidden
	tab._contentPage.ClipsDescendants = true
	tab._contentPage.Parent = window._contentContainer
	tab._contentPage.CanvasSize = UDim2.new(0, 0, 0, 0) -- Start with zero canvas size
	tab._contentPage.ScrollBarThickness = 6
	tab._contentPage.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    tab._contentPage.ScrollingDirection = Enum.ScrollingDirection.Y
    tab._contentPage.AutomaticCanvasSize = Enum.AutomaticSize.Y -- Let layout determine height
    tab._contentPage.CanvasPosition = Vector2.new() -- Ensure starts at top

	local contentPadding = Instance.new("UIPadding", tab._contentPage)
	contentPadding.PaddingTop = UDim.new(0, 10)
	contentPadding.PaddingBottom = UDim.new(0, 10)
	contentPadding.PaddingLeft = UDim.new(0, 10)
	contentPadding.PaddingRight = UDim.new(0, 10)

	tab._contentLayout = Instance.new("UIListLayout", tab._contentPage)
	tab._contentLayout.Padding = UDim.new(0, 15) -- Spacing between elements
	tab._contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
	tab._contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left

    -- Store content page reference
	window._contentPages[tab.Name] = tab._contentPage
    table.insert(window._tabs, tab)

	-- Connect Tab Button Click
	tabButton.MouseButton1Click:Connect(function()
        window:_switchTab(tab.Name)
    end)

    -- Activate the first tab added automatically
    if #window._tabs == 1 then
        task.defer(window._switchTab, window, tab.Name) -- Use task.defer to ensure UI is loaded
    end

	return tab -- Return the tab object for adding elements
end

--==============================================================================--
--                               ELEMENT ADDERS                                 --
--==============================================================================--
-- These methods are called on a Tab object (e.g., Tab:AddSlider)

function HydraLib:AddSlider(config)
    local tab = self -- Assumes called like Tab:AddSlider(...)
    if not tab or not tab._contentPage then
        error("AddSlider must be called on a Tab object created by MakeTab.")
        return
    end
    config = config or {}
    config._LayoutOrder = tab._layoutOrderCounter
    tab._layoutOrderCounter = tab._layoutOrderCounter + 1

    local element, setter = _createSlider(tab._contentPage, config)
    local controlObject = {
        Type = "Slider",
        Element = element,
        Set = setter,
        -- Get = getter -- If getter was returned by _createSlider
    }
    -- Optional: store controlObject in tab._controls if needed for flags/etc.
    return controlObject -- Return object with Set method
end

function HydraLib:AddToggle(config)
    local tab = self
     if not tab or not tab._contentPage then
        error("AddToggle must be called on a Tab object created by MakeTab.")
        return
    end
    config = config or {}
    config._LayoutOrder = tab._layoutOrderCounter
    tab._layoutOrderCounter = tab._layoutOrderCounter + 1

    local element, setter = _createToggle(tab._contentPage, config)
    local controlObject = {
        Type = "Toggle",
        Element = element,
        Set = setter,
        -- Get = getter
    }
    return controlObject
end

function HydraLib:AddDropdown(config)
     local tab = self
     if not tab or not tab._contentPage then
        error("AddDropdown must be called on a Tab object created by MakeTab.")
        return
    end
    config = config or {}
    config._LayoutOrder = tab._layoutOrderCounter
    tab._layoutOrderCounter = tab._layoutOrderCounter + 1

    local element, setter, refresher = _createDropdown(tab._contentPage, config, tab._window._screenGui)
    local controlObject = {
        Type = "Dropdown",
        Element = element,
        Set = setter,
        Refresh = refresher,
        -- Get = getter
    }
    return controlObject
end

--==============================================================================--
--                             LIBRARY UTILITIES                                --
--==============================================================================--

function HydraLib:Destroy()
    -- If called on the main library object, destroy all windows
    if self == HydraLib then
        for i = #HydraLib._windows, 1, -1 do
            local window = HydraLib._windows[i]
            if window and window.Destroy then
                window:Destroy() -- Call individual window destroy
            end
            table.remove(HydraLib._windows, i)
        end
        ZINDEX_COUNTER = 1 -- Reset counter if all are destroyed
    else
        -- Assume 'self' is a window object
        local window = self
        if window and window._screenGui and window._screenGui.Parent then
            window._closeCallback() -- Execute user's callback
            window._screenGui:Destroy()
            -- Remove from tracked windows
            for i, w in ipairs(HydraLib._windows) do
                if w == window then
                    table.remove(HydraLib._windows, i)
                    break
                end
            end
        end
    end
end

-- Expose the main library object
return HydraLib
